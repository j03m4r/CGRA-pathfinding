#
# Gobal settings & defaults
#

[AllMappers]
# Possible hint to heuristics
arch_id =
# Maximum number of simultaneous threads that a mapper should try to use
max_threads = 1
# Set to non-empty to enable computation and dumping of ILP irreducable inconsistent subsystems
model_IIS_dump_filename =
# Set to non-empty to enable dumping of ILP models
model_dump_filename =
# Seed for all preudo-random operations in a mapper
seed = 0
# Controls logging. A value of 0 requests silence.
verbosity = 0

#
# The rest are mapper-specific & overrides
#

[BothSmallTimeThenHeurFullTime]
# The first run of ILPHeuristicMapper will be launched this many seconds after ILPMapper
initial_heur_wait = 10
# Max time of the first iteration
initial_timeout = 25
max_threads = 2
# Time limit applied to second run of ILPMapper
secondary_limit = 180

[ClusteredMapper]
# Flag to set if the benchmark gets clustered or no
cluster = true
# Placement cost function could be 0 (BoundaryBox cost) or 1 (Scheduling cost)
cost_function = 1
# Sets the threshold of acceptable fanout
fanout_threshold = 5
# history factor increment
hfactor_factor = 1.010000
# History factor
initial_hfactor = 0.200000
# Initial FU and routing overuse penalty
initial_pfactor = 0.010000
# Temperature that the anneal starts at
initial_temperature_method =
# Multiplicative factor for overuse penalty, per iteration
pfactor_factor = 1.070000
# File to dump csv data status of each iteration. Empty disables.
progress_dump_filename =
# Set the number of ram ports
ram_ports = 0
seed = 10
# Swaps per op node, per iteration
swap_factor = 10

[ILPHeuristicMapper]
# Allow ops to map to more than one FU
allow_recomputation = false
# Assume a dataflow-like architecture
allow_unbalanced_latency = false
# Low-overhead option that gives a better estimate of what mapping time would be like if arch-specific data was saved to disk
do_cache_warmup = true
# At each number-of-neighbours, if unable to route any placements, try placing & routing at the same time
do_final_combined_attempt = false
# At each number-of-neighbours, try solving without modelling routing first
do_test_placement = true
# Specify one of the available cost functions on functional units.
fu_coster =
# The number-of-neighbours to start solving at. Default depends on arch_id
nneigh_start =
# The amount number-of-neighbours is increased between attempts
nneigh_step = 2
# The last number-of-neighbours to try. Default depends on arch_id
nneigh_stop =

[ILPMapper]
enable_topological_order_costing_by_max = 0
enable_topological_order_costing_by_sum = 0
enable_topological_order_mode = 0
lazy_constraint_add_mode = 0
# Relative threshold on the difference between the primal and dual cost functions to consider a solution optimal
mip_gap = 0.200000
per_value_topological_order_variables = 0
# Maximum number of solutions that will be considered before giving up and taking the lowest cost one found. Larger values generally lead to more optimal solutions.
solution_limit = 1
